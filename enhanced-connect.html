<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Professional Video Call</title>
  <link rel="stylesheet" href="connect.css" />
  <link rel="stylesheet" href="enhanced-styles.css" />
  <script src="https://cdn.socket.io/4.5.0/socket.io.min.js"></script>
</head>
<body>
  <div id="bg-3d" style="position:fixed;top:0;left:0;width:100vw;height:100vh;z-index:-1;"></div>
  <div class="main-content">
    <h2><img src="Assets/logo.avif" alt="Logo" style="height:2.2em;vertical-align:middle;margin-right:0.5em;border-radius:8px;box-shadow:0 2px 8px #0002;">Professional Video Call</h2>
    
    <div class="meeting-info">
      <div class="meeting-id">
        <span class="meeting-id-label">Meeting ID:</span>
        <div class="meeting-id-value" id="meetingIdValue">
          <span id="roomIdDisplay">Waiting for room...</span>
          <span class="copy-btn" id="copyMeetingIdBtn">
            <svg width="16" height="16" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
              <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
              <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
            </svg>
          </span>
        </div>
      </div>
      <div class="meeting-duration">
        <svg width="16" height="16" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
          <circle cx="12" cy="12" r="10"></circle>
          <polyline points="12 6 12 12 16 14"></polyline>
        </svg>
        <span id="meetingDuration">00:00:00</span>
      </div>
      <div class="encryption-indicator" id="encryptionIndicator" title="End-to-end encryption">
        <svg width="16" height="16" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
          <rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect>
          <path d="M7 11V7a5 5 0 0 1 10 0v4"></path>
        </svg>
        <span id="encryptionStatus">Initializing...</span>
      </div>
    </div>
    
    <div class="video-container">
      <div class="video-card" id="localVideoCard">
        <video id="localVideo" autoplay playsinline></video>
        <div class="video-overlay">
          <div class="video-info">
            <div class="user-avatar-small" id="localUserAvatar"></div>
            <span id="localUserName">You</span>
          </div>
          <div class="video-status">
            <div class="mic-status" id="localMicStatus">
              <svg width="16" height="16" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
                <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path>
                <path d="M19 10v2a7 7 0 0 1-14 0v-2"></path>
                <line x1="12" y1="19" x2="12" y2="23"></line>
                <line x1="8" y1="23" x2="16" y2="23"></line>
              </svg>
            </div>
            <div class="camera-status" id="localCameraStatus">
              <svg width="16" height="16" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
                <polygon points="23 7 16 12 23 17 23 7"></polygon>
                <rect x="1" y="5" width="15" height="14" rx="2" ry="2"></rect>
              </svg>
            </div>
          </div>
        </div>
        <div class="participant-avatar" id="localAvatar"></div>
        <div class="video-label">You</div>
        <div class="call-actions-menu">
          <div class="action-icon" title="Focus View" id="focusLocalBtn">
            <svg width="16" height="16" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
              <polyline points="15 3 21 3 21 9"></polyline>
              <polyline points="9 21 3 21 3 15"></polyline>
              <line x1="21" y1="3" x2="14" y2="10"></line>
              <line x1="3" y1="21" x2="10" y2="14"></line>
            </svg>
          </div>
          <div class="action-icon" title="Apply Filter" id="filterLocalBtn">
            <svg width="16" height="16" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
              <circle cx="12" cy="12" r="10"></circle>
              <path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"></path>
              <line x1="12" y1="17" x2="12.01" y2="17"></line>
            </svg>
          </div>
          <div class="action-icon" title="Take Snapshot" id="snapshotLocalBtn">
            <svg width="16" height="16" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
              <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"></path>
              <circle cx="12" cy="13" r="4"></circle>
            </svg>
          </div>
        </div>
      </div>
      
      <div class="video-card" id="remoteVideoCard">
        <video id="remoteVideo" autoplay playsinline></video>
        <div class="video-overlay">
          <div class="video-info">
            <div class="user-avatar-small" id="remoteUserAvatar"></div>
            <span id="remoteUserName">Remote User</span>
          </div>
          <div class="video-status">
            <div class="mic-status" id="remoteMicStatus">
              <svg width="16" height="16" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
                <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path>
                <path d="M19 10v2a7 7 0 0 1-14 0v-2"></path>
                <line x1="12" y1="19" x2="12" y2="23"></line>
                <line x1="8" y1="23" x2="16" y2="23"></line>
              </svg>
            </div>
            <div class="camera-status" id="remoteCameraStatus">
              <svg width="16" height="16" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
                <polygon points="23 7 16 12 23 17 23 7"></polygon>
                <rect x="1" y="5" width="15" height="14" rx="2" ry="2"></rect>
              </svg>
            </div>
          </div>
        </div>
        <div class="participant-avatar" id="remoteAvatar"></div>
        <div class="video-label">Remote</div>
        <div class="call-actions-menu">
          <div class="action-icon" title="Focus View" id="focusRemoteBtn">
            <svg width="16" height="16" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
              <polyline points="15 3 21 3 21 9"></polyline>
              <polyline points="9 21 3 21 3 15"></polyline>
              <line x1="21" y1="3" x2="14" y2="10"></line>
              <line x1="3" y1="21" x2="10" y2="14"></line>
            </svg>
          </div>
          <div class="action-icon" title="Pin Video" id="pinRemoteBtn">
            <svg width="16" height="16" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
              <path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path>
              <circle cx="12" cy="10" r="3"></circle>
            </svg>
          </div>
          <div class="action-icon" title="Fullscreen" id="fullscreenRemoteBtn">
            <svg width="16" height="16" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
              <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"></path>
            </svg>
          </div>
        </div>
      </div>
    </div>
    
    <div class="status-indicator">
      <span class="status-dot disconnected" id="callStatusDot"></span>
      <span id="callStatusText">Disconnected</span>
    </div>
    
    <div class="controls">
      <button id="startCall"><svg width="18" height="18" style="vertical-align:middle;margin-right:6px;" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M22 16.92V19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v2.08"></path><path d="M16 12l-4-4-4 4m4-4v12"></path></svg>Start Call</button>
      <button id="endCall" disabled><svg width="18" height="18" style="vertical-align:middle;margin-right:6px;" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M6 18L18 6M6 6l12 12"></path></svg>End Call</button>
    </div>
    
    <div class="additional-controls">
      <button id="toggleChatBtn" class="control-btn toggle-btn">
        <svg width="20" height="20" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
          <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>
        </svg>
        Chat
      </button>
      <button id="toggleScreenShareBtn" class="control-btn toggle-btn">
        <svg width="20" height="20" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
          <rect x="2" y="3" width="20" height="14" rx="2" ry="2"></rect>
          <line x1="8" y1="21" x2="16" y2="21"></line>
          <line x1="12" y1="17" x2="12" y2="21"></line>
        </svg>
        Share Screen
      </button>
      <button id="toggleMuteBtn" class="control-btn toggle-btn">
        <svg width="20" height="20" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24" id="muteIcon">
          <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path>
          <path d="M19 10v2a7 7 0 0 1-14 0v-2"></path>
          <line x1="12" y1="19" x2="12" y2="23"></line>
          <line x1="8" y1="23" x2="16" y2="23"></line>
        </svg>
        Mute
      </button>
      <button id="toggleVideoBtn" class="control-btn toggle-btn">
        <svg width="20" height="20" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24" id="videoIcon">
          <polygon points="23 7 16 12 23 17 23 7"></polygon>
          <rect x="1" y="5" width="15" height="14" rx="2" ry="2"></rect>
        </svg>
        Video
      </button>
      <button id="toggleFileSharingBtn" class="control-btn toggle-btn">
        <svg width="20" height="20" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
          <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
          <polyline points="17 8 12 3 7 8"></polyline>
          <line x1="12" y1="3" x2="12" y2="15"></line>
        </svg>
        Share Files
      </button>
      <button id="toggleParticipantsBtn" class="control-btn toggle-btn">
        <svg width="20" height="20" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
          <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path>
          <circle cx="9" cy="7" r="4"></circle>
          <path d="M23 21v-2a4 4 0 0 0-3-3.87"></path>
          <path d="M16 3.13a4 4 0 0 1 0 7.75"></path>
        </svg>
        Participants
      </button>
    </div>
    
    <section class="transcript-section transcript-container">
      <p><strong><br>Live Transcript:<br></strong></p>
      <div id="transcript">Waiting for speech...</div>
    </section>
    
    <!-- Chat interface -->
    <div class="chat-container" id="chatContainer">
      <div class="chat-header">
        <span>Chat</span>
        <button class="close-btn" id="closeChatBtn">×</button>
      </div>
      <div class="chat-messages" id="chatMessages"></div>
      <div class="chat-input">
        <input type="text" id="chatInput" placeholder="Type a message...">
        <button id="sendMessageBtn">Send</button>
      </div>
    </div>
    
    <!-- Room joining modal -->
    <div class="modal" id="roomModal">
      <div class="modal-content">
        <h3>Join Video Call</h3>
        <div class="input-group">
          <label for="userName">Your Name</label>
          <input type="text" id="userName" placeholder="Enter your name">
        </div>
        <div class="input-group">
          <label for="roomId">Room ID</label>
          <input type="text" id="roomId" placeholder="Enter room ID">
          <button id="generateRoomBtn">Generate</button>
        </div>
        <button id="joinRoomBtn" class="primary-btn">Join Room</button>
      </div>
    </div>
    
    <!-- File sharing panel -->
    <div class="file-sharing" id="fileSharing">
      <div class="file-header">
        <h4>Share Files</h4>
        <button class="close-btn" id="closeSharingBtn">×</button>
      </div>
      <div class="file-drop" id="fileDropZone">
        <svg width="48" height="48" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
          <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
          <polyline points="17 8 12 3 7 8"></polyline>
          <line x1="12" y1="3" x2="12" y2="15"></line>
        </svg>
        <p>Drop files here or click to browse</p>
        <input type="file" id="fileInput" multiple style="display:none">
      </div>
      <div class="file-list" id="fileList"></div>
    </div>
    
    <!-- Participants panel -->
    <div class="participants-panel" id="participantsPanel">
      <div class="panel-header">
        <h3>Participants (0)</h3>
        <button class="close-btn" id="closeParticipantsBtn">×</button>
      </div>
      <div class="participants-list" id="participantsList"></div>
    </div>
    
    <!-- Recording indicator -->
    <div class="recording-indicator" id="recordingIndicator" style="display:none">
      <div class="recording-dot"></div>
      <span>Recording</span>
      <span id="recordingTime">00:00</span>
    </div>
    
    <!-- Floating action button -->
    <div class="fab" id="fab">
      <svg width="24" height="24" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
        <circle cx="12" cy="12" r="1"></circle>
        <circle cx="19" cy="12" r="1"></circle>
        <circle cx="5" cy="12" r="1"></circle>
      </svg>
      <div class="fab-menu">
        <div class="fab-item" id="fabShareFiles">
          <svg width="20" height="20" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
            <polyline points="17 8 12 3 7 8"></polyline>
            <line x1="12" y1="3" x2="12" y2="15"></line>
          </svg>
          Share Files
        </div>
        <div class="fab-item" id="fabParticipants">
          <svg width="20" height="20" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
            <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path>
            <circle cx="9" cy="7" r="4"></circle>
            <path d="M23 21v-2a4 4 0 0 0-3-3.87"></path>
            <path d="M16 3.13a4 4 0 0 1 0 7.75"></path>
          </svg>
          Participants
        </div>
        <div class="fab-item" id="fabRecord">
          <svg width="20" height="20" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
            <circle cx="12" cy="12" r="10"></circle>
            <circle cx="12" cy="12" r="3"></circle>
          </svg>
          Record Meeting
        </div>
      </div>
    </div>
    
    <!-- Toast container -->
    <div class="toast-container" id="toastContainer"></div>
  </div>
  
  <script type="module" src="3d-bg.js"></script>
  <script type="module" src="file-sharing.js"></script>
  <script type="module" src="file-sharing-adapter.js"></script>
  <script type="module" src="encryption-adapter.js"></script>
  <script type="module" src="recording-adapter.js"></script>
  <script type="module">
    import { create3DBackground } from './3d-bg.js';
    import { initFileSharing } from './file-sharing-adapter.js';
    import { E2EEncryptionManager } from './encryption-adapter.js';
    import { RecordingManager } from './recording-adapter.js';
    
    // Initialize 3D background
    create3DBackground('bg-3d');
    
    // Connect to Socket.IO server
    const socket = io('http://localhost:3000');
    
    // Initialize encryption and recording managers
    const encryptionManager = new E2EEncryptionManager();
    const recordingManager = new RecordingManager();
    let encryptionInitialized = false;
    let recordingInitialized = false;

    let localStream = null;
    let peerConnection = null;
    let screenStream = null;
    let isScreenSharing = false;
    let isMuted = false;
    let isVideoOff = false;
    let currentRoom = null;
    let userName = null;
    let remoteUserDisplayName = "Remote User";
    let participants = [];
    let isRecording = false;
    const config = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };

    // Get element references
    const localVideo = document.getElementById('localVideo');
    const remoteVideo = document.getElementById('remoteVideo');
    const startCallButton = document.getElementById('startCall');
    const endCallButton = document.getElementById('endCall');
    const transcriptDiv = document.getElementById("transcript");
    const callStatusDot = document.getElementById('callStatusDot');
    const callStatusText = document.getElementById('callStatusText');
    
    // Chat elements
    const chatContainer = document.getElementById('chatContainer');
    const chatMessages = document.getElementById('chatMessages');
    const chatInput = document.getElementById('chatInput');
    const sendMessageBtn = document.getElementById('sendMessageBtn');
    const toggleChatBtn = document.getElementById('toggleChatBtn');
    const closeChatBtn = document.getElementById('closeChatBtn');
    
    // Media control elements
    const toggleScreenShareBtn = document.getElementById('toggleScreenShareBtn');
    const toggleMuteBtn = document.getElementById('toggleMuteBtn');
    const toggleVideoBtn = document.getElementById('toggleVideoBtn');
    const muteIcon = document.getElementById('muteIcon');
    const videoIcon = document.getElementById('videoIcon');
    
    // Room modal elements
    const roomModal = document.getElementById('roomModal');
    const userNameInput = document.getElementById('userName');
    const roomIdInput = document.getElementById('roomId');
    const generateRoomBtn = document.getElementById('generateRoomBtn');
    const joinRoomBtn = document.getElementById('joinRoomBtn');
    
    // Video card elements
    const localVideoCard = document.getElementById('localVideoCard');
    const remoteVideoCard = document.getElementById('remoteVideoCard');
    const localAvatar = document.getElementById('localAvatar');
    const remoteAvatar = document.getElementById('remoteAvatar');
    const localUserName = document.getElementById('localUserName');
    const remoteUserName = document.getElementById('remoteUserName');
    const roomIdDisplay = document.getElementById('roomIdDisplay');
    
    // File sharing elements
    const fileSharing = document.getElementById('fileSharing');
    const toggleFileSharingBtn = document.getElementById('toggleFileSharingBtn');
    const closeSharingBtn = document.getElementById('closeSharingBtn');
    
    // Participants panel elements
    const participantsPanel = document.getElementById('participantsPanel');
    const toggleParticipantsBtn = document.getElementById('toggleParticipantsBtn');
    const closeParticipantsBtn = document.getElementById('closeParticipantsBtn');
    
    // FAB elements
    const fab = document.getElementById('fab');
    const fabShareFiles = document.getElementById('fabShareFiles');
    const fabParticipants = document.getElementById('fabParticipants');
    const fabRecord = document.getElementById('fabRecord');
    
    // Recording elements
    const recordingIndicator = document.getElementById('recordingIndicator');
    
    // Utility elements
    const copyMeetingIdBtn = document.getElementById('copyMeetingIdBtn');
    
    // Video filters
    const filterLocalBtn = document.getElementById('filterLocalBtn');
    const focusLocalBtn = document.getElementById('focusLocalBtn');
    const snapshotLocalBtn = document.getElementById('snapshotLocalBtn');
    const focusRemoteBtn = document.getElementById('focusRemoteBtn');
    const pinRemoteBtn = document.getElementById('pinRemoteBtn');
    const fullscreenRemoteBtn = document.getElementById('fullscreenRemoteBtn');

    // Show room modal on page load
    window.addEventListener('DOMContentLoaded', () => {
      roomModal.style.display = 'flex';
      
      // Initialize avatars
      updateAvatars();
    });

    // Generate random room ID
    generateRoomBtn.addEventListener('click', () => {
      const randomId = Math.random().toString(36).substring(2, 10);
      roomIdInput.value = randomId;
    });

    // Join room
    joinRoomBtn.addEventListener('click', () => {
      userName = userNameInput.value.trim();
      currentRoom = roomIdInput.value.trim();
      
      if (!userName) {
        showToast('Please enter your name', 'error');
        return;
      }
      
      if (!currentRoom) {
        showToast('Please enter a room ID or generate one', 'error');
        return;
      }
      
      // Hide modal
      roomModal.style.display = 'none';
      
      // Update UI to show room info
      document.querySelector('h2').innerText = `Professional Video Call`;
      roomIdDisplay.textContent = currentRoom;
      localUserName.textContent = userName;
      updateAvatars();
      
      // Join the room
      socket.emit('join-room', {
        roomId: currentRoom,
        userId: socket.id,
        userName: userName
      });
      
      // Initialize file sharing with encryption
      initFileSharing({
        encryptionManager: encryptionManager,
        socket: socket,
        roomId: currentRoom
      });
      
      showToast(`Joined room: ${currentRoom}`, 'success');
      
      // Start meeting timer
      startMeetingTimer();
    });

    // Event Listeners
    startCallButton.addEventListener('click', startCall);
    endCallButton.addEventListener('click', endCall);
    
    // Chat controls
    toggleChatBtn.addEventListener('click', () => {
      chatContainer.style.display = chatContainer.style.display === 'flex' ? 'none' : 'flex';
      toggleChatBtn.classList.toggle('active');
    });
    
    closeChatBtn.addEventListener('click', () => {
      chatContainer.style.display = 'none';
      toggleChatBtn.classList.remove('active');
    });
    
    sendMessageBtn.addEventListener('click', sendChatMessage);
    chatInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') sendChatMessage();
    });
    
    // Media controls
    toggleScreenShareBtn.addEventListener('click', toggleScreenShare);
    toggleMuteBtn.addEventListener('click', toggleMute);
    toggleVideoBtn.addEventListener('click', toggleVideo);
    
    // File sharing controls
    toggleFileSharingBtn.addEventListener('click', () => {
      fileSharing.classList.toggle('active');
      toggleFileSharingBtn.classList.toggle('active');
    });
    
    closeSharingBtn.addEventListener('click', () => {
      fileSharing.classList.remove('active');
      toggleFileSharingBtn.classList.remove('active');
    });
    
    // Participants panel controls
    toggleParticipantsBtn.addEventListener('click', () => {
      participantsPanel.classList.toggle('active');
      toggleParticipantsBtn.classList.toggle('active');
    });
    
    closeParticipantsBtn.addEventListener('click', () => {
      participantsPanel.classList.remove('active');
      toggleParticipantsBtn.classList.remove('active');
    });
    
    // FAB controls
    fab.addEventListener('click', () => {
      fab.classList.toggle('active');
    });
    
    fabShareFiles.addEventListener('click', () => {
      fileSharing.classList.add('active');
      toggleFileSharingBtn.classList.add('active');
      fab.classList.remove('active');
    });
    
    fabParticipants.addEventListener('click', () => {
      participantsPanel.classList.add('active');
      toggleParticipantsBtn.classList.add('active');
      fab.classList.remove('active');
    });
    
    fabRecord.addEventListener('click', () => {
      if (!isRecording) {
        startRecording();
      } else {
        stopRecording();
      }
      fab.classList.remove('active');
    });
    
    // Copy meeting ID
    copyMeetingIdBtn.addEventListener('click', () => {
      copyToClipboard(currentRoom);
      showToast('Meeting ID copied to clipboard', 'info');
    });
    
    // Video card action buttons
    filterLocalBtn.addEventListener('click', () => {
      applyVideoFilter(localVideo);
    });
    
    focusLocalBtn.addEventListener('click', () => {
      focusVideo(localVideoCard);
    });
    
    snapshotLocalBtn.addEventListener('click', () => {
      takeSnapshot(localVideo);
    });
    
    focusRemoteBtn.addEventListener('click', () => {
      focusVideo(remoteVideoCard);
    });
    
    pinRemoteBtn.addEventListener('click', () => {
      pinRemoteBtn.classList.toggle('active');
      remoteVideoCard.classList.toggle('pinned');
    });
    
    fullscreenRemoteBtn.addEventListener('click', () => {
      if (remoteVideo.requestFullscreen) {
        remoteVideo.requestFullscreen();
      } else if (remoteVideo.webkitRequestFullscreen) {
        remoteVideo.webkitRequestFullscreen();
      }
    });

    function setCallStatus(connected) {
      if (connected) {
        callStatusDot.classList.remove('disconnected');
        callStatusDot.classList.add('connected');
        callStatusText.textContent = 'Connected';
        showToast('Call connected', 'success');
      } else {
        callStatusDot.classList.remove('connected');
        callStatusDot.classList.add('disconnected');
        callStatusText.textContent = 'Disconnected';
      }
    }

    async function startCall() {
      try {
        // Get user media
        localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
        localVideo.srcObject = localStream;

        // Create a new peer connection
        peerConnection = new RTCPeerConnection(config);

        // Add local stream tracks to peer connection
        localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));

        // Display remote stream when available
        peerConnection.ontrack = event => {
          if (event.streams && event.streams[0]) {
            remoteVideo.srcObject = event.streams[0];
            remoteVideoCard.classList.remove('video-off');
          }
        };

        // ICE candidate handling
        peerConnection.onicecandidate = event => {
          if (event.candidate) {
            socket.emit('ice-candidate', {
              candidate: event.candidate,
              target: currentRoom // Send to room
            });
          }
        };

        // Connection state
        peerConnection.onconnectionstatechange = () => {
          setCallStatus(peerConnection.connectionState === 'connected');
        };

        // Create and send offer
        const offer = await peerConnection.createOffer();
        await peerConnection.setLocalDescription(offer);
        socket.emit('offer', {
          offer: offer,
          target: currentRoom // Send to room
        });

        // Enable the End Call button and disable Start Call button
        startCallButton.disabled = true;
        endCallButton.disabled = false;
        setCallStatus(false);
        showToast('Starting call...', 'info');
        
        // Update video card UI
        localVideoCard.classList.remove('video-off');
      } catch (error) {
        console.error("Error starting call:", error);
        showToast("Could not start the call. Please check your webcam and microphone permissions.", 'error');
      }
    }

    // Listen for incoming offer
    socket.on('offer', async data => {
      try {
        // If no local stream exists, get it first
        if (!localStream) {
          localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
          localVideo.srcObject = localStream;
          localVideoCard.classList.remove('video-off');
        }

        peerConnection = new RTCPeerConnection(config);
        localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));

        peerConnection.ontrack = event => {
          if (event.streams && event.streams[0]) {
            remoteVideo.srcObject = event.streams[0];
            remoteVideoCard.classList.remove('video-off');
          }
        };

        peerConnection.onicecandidate = event => {
          if (event.candidate) {
            socket.emit('ice-candidate', {
              candidate: event.candidate,
              target: data.sender // Send back to sender
            });
          }
        };

        peerConnection.onconnectionstatechange = () => {
          setCallStatus(peerConnection.connectionState === 'connected');
        };

        await peerConnection.setRemoteDescription(new RTCSessionDescription(data.offer));
        const answer = await peerConnection.createAnswer();
        await peerConnection.setLocalDescription(answer);
        socket.emit('answer', {
          answer: answer,
          target: data.sender // Send back to sender
        });

        // Enable End Call button
        startCallButton.disabled = true;
        endCallButton.disabled = false;
        setCallStatus(false);
        showToast('Incoming call...', 'info');
      } catch (error) {
        console.error("Error handling offer:", error);
        showToast("Error handling incoming call", 'error');
      }
    });

    // Listen for answer from remote peer
    socket.on('answer', async data => {
      try {
        await peerConnection.setRemoteDescription(new RTCSessionDescription(data.answer));
      } catch (error) {
        console.error("Error setting remote description:", error);
        showToast("Error connecting to remote peer", 'error');
      }
    });

    // Listen for ICE candidates from remote peer
    socket.on('ice-candidate', async data => {
      try {
        if (peerConnection) {
          await peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
        }
      } catch (error) {
        console.error("Error adding received ICE candidate:", error);
      }
    });

    // Handle new user joining
    socket.on('user-joined', user => {
      addChatSystemMessage(`${user.userName} joined the room`);
      
      // Add to participants array
      if (!participants.some(p => p.id === user.userId)) {
        participants.push({
          id: user.userId,
          name: user.userName
        });
           // Update UI
      updateParticipantsList();
      remoteUserName.textContent = user.userName;
      remoteUserDisplayName = user.userName;
      updateAvatars();
      }
      
      showToast(`${user.userName} joined the room`, 'info');
    });
    
    // Handle user leaving
    socket.on('user-left', user => {
      addChatSystemMessage(`${user.userName} left the room`);
      
      // Remove from participants array
      participants = participants.filter(p => p.id !== user.userId);
      
      // Update UI
      updateParticipantsList();
      
      // If we were connected to this user, reset UI
      if (remoteVideo.srcObject && peerConnection.connectionState === 'connected') {
        endCall();
      }
      
      showToast(`${user.userName} left the room`, 'warning');
    });
    
    // Handle chat messages
    socket.on('chat-message', data => {
      // Check if message is encrypted
      if (data.encrypted && encryptionInitialized && encryptionManager.secureChannelEstablished) {
        // Decrypt the message
        encryptionManager.decryptMessage(data.message)
          .then(decryptedMessage => {
            addChatMessage(data.sender, decryptedMessage, false);
            
            // Show toast notification if chat is hidden
            if (chatContainer.style.display !== 'flex') {
              showToast(`New encrypted message from ${data.sender}`, 'info');
            }
          })
          .catch(error => {
            console.error('Error decrypting message:', error);
            addChatSystemMessage(`Failed to decrypt message from ${data.sender}: ${error.message}`);
          });
      } else {
        // Handle unencrypted message
        addChatMessage(data.sender, data.message, false);
        
        // Show toast notification if chat is hidden
        if (chatContainer.style.display !== 'flex') {
          showToast(`New message from ${data.sender}`, 'info');
        }
      }
    });
    
    // Handle screen sharing notifications
    socket.on('screen-share-started', data => {
      addChatSystemMessage(`${data.userName} started sharing their screen`);
      showToast(`${data.userName} started screen sharing`, 'info');
    });
    
    socket.on('screen-share-stopped', data => {
      addChatSystemMessage(`Screen sharing stopped`);
      showToast('Screen sharing stopped', 'info');
    });
    
    // Handle recording notifications
    socket.on('recording-started', data => {
      addChatSystemMessage(`${data.userName} started recording the meeting`);
      showToast(`${data.userName} started recording`, 'warning');
    });
    
    socket.on('recording-stopped', data => {
      addChatSystemMessage(`Recording stopped`);
      showToast('Recording stopped', 'info');
    });

    function endCall() {
      if (peerConnection) {
        peerConnection.close();
        peerConnection = null;
      }
      if (localStream) {
        // Stop all media tracks
        localStream.getTracks().forEach(track => track.stop());
        localStream = null;
      }
      if (screenStream) {
        screenStream.getTracks().forEach(track => track.stop());
        screenStream = null;
        isScreenSharing = false;
        toggleScreenShareBtn.classList.remove('active');
      }
      localVideo.srcObject = null;
      remoteVideo.srcObject = null;
      startCallButton.disabled = false;
      endCallButton.disabled = true;
      setCallStatus(false);
      
      // Update video card UI
      localVideoCard.classList.add('video-off');
      remoteVideoCard.classList.add('video-off');
      
      // Reset media controls
      toggleMuteBtn.classList.remove('active', 'muted');
      toggleVideoBtn.classList.remove('active', 'video-off');
      
      showToast('Call ended', 'info');
    }
    
    // Chat functions
    function sendChatMessage() {
      const message = chatInput.value.trim();
      if (!message) return;
      
      // Add message to local chat
      addChatMessage(userName, message, true);
      
      // If encryption is initialized, encrypt the message
      if (encryptionInitialized && encryptionManager.secureChannelEstablished) {
        try {
          // Encrypt the message
          encryptionManager.encryptMessage(message)
            .then(encryptedMessage => {
              // Send encrypted message
              socket.emit('chat-message', {
                message: encryptedMessage,
                encrypted: true,
                roomId: currentRoom
              });
            })
            .catch(error => {
              console.error('Error encrypting message:', error);
              
              // Fall back to unencrypted message
              socket.emit('chat-message', {
                message: message,
                encrypted: false,
                roomId: currentRoom
              });
            });
        } catch (error) {
          console.error('Error encrypting message:', error);
          
          // Fall back to unencrypted message
          socket.emit('chat-message', {
            message: message,
            encrypted: false,
            roomId: currentRoom
          });
        }
      } else {
        // Send unencrypted message
        socket.emit('chat-message', {
          message: message,
          encrypted: false,
          roomId: currentRoom
        });
      }
      
      // Clear input
      chatInput.value = '';
    }
    
    function addChatMessage(sender, message, isOutgoing) {
      const messageElement = document.createElement('div');
      messageElement.classList.add('chat-message');
      messageElement.classList.add(isOutgoing ? 'outgoing' : 'incoming');
      
      const content = document.createElement('div');
      content.classList.add('message-content');
      content.textContent = message;
      
      const meta = document.createElement('div');
      meta.classList.add('message-meta');
      
      // Only show sender name for incoming messages
      if (!isOutgoing) {
        meta.textContent = sender;
      } else {
        meta.textContent = 'You';
      }
      
      messageElement.appendChild(content);
      messageElement.appendChild(meta);
      chatMessages.appendChild(messageElement);
      
      // Auto scroll to bottom
      chatMessages.scrollTop = chatMessages.scrollHeight;
    }
    
    function addChatSystemMessage(message) {
      const messageElement = document.createElement('div');
      messageElement.classList.add('chat-message', 'system');
      messageElement.style.backgroundColor = 'rgba(0,0,0,0.2)';
      messageElement.style.color = 'rgba(255,255,255,0.7)';
      messageElement.style.textAlign = 'center';
      messageElement.style.margin = '0.5rem auto';
      messageElement.style.padding = '0.5rem';
      messageElement.style.borderRadius = '8px';
      messageElement.style.maxWidth = '100%';
      
      messageElement.textContent = message;
      chatMessages.appendChild(messageElement);
      
      // Auto scroll to bottom
      chatMessages.scrollTop = chatMessages.scrollHeight;
    }
    
    // Media control functions
    async function toggleScreenShare() {
      if (isScreenSharing) {
        // Stop screen sharing
        if (screenStream) {
          screenStream.getTracks().forEach(track => {
            track.stop();
            
            // Remove from peer connection
            const senders = peerConnection.getSenders();
            const sender = senders.find(s => s.track.kind === track.kind);
            if (sender) {
              peerConnection.removeTrack(sender);
            }
          });
          
          screenStream = null;
        }
        
        // Add back camera video
        if (localStream) {
          const videoTrack = localStream.getVideoTracks()[0];
          if (videoTrack) {
            const senders = peerConnection.getSenders();
            const sender = senders.find(s => s.track.kind === 'video');
            if (sender) {
              sender.replaceTrack(videoTrack);
            }
            
            // Update local video
            localVideo.srcObject = localStream;
          }
        }
        
        isScreenSharing = false;
        toggleScreenShareBtn.classList.remove('active');
        toggleScreenShareBtn.innerHTML = `
          <svg width="20" height="20" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
            <rect x="2" y="3" width="20" height="14" rx="2" ry="2"></rect>
            <line x1="8" y1="21" x2="16" y2="21"></line>
            <line x1="12" y1="17" x2="12" y2="21"></line>
          </svg>
          Share Screen
        `;
        
        // Notify others
        socket.emit('stop-screen-share', { roomId: currentRoom });
        showToast('Screen sharing stopped', 'info');
        
      } else {
        // Start screen sharing
        try {
          screenStream = await navigator.mediaDevices.getDisplayMedia({ video: true });
          
          // Update local video preview
          localVideo.srcObject = screenStream;
          
          // Replace video track in peer connection
          if (peerConnection) {
            const videoTrack = screenStream.getVideoTracks()[0];
            const senders = peerConnection.getSenders();
            const sender = senders.find(s => s.track.kind === 'video');
            if (sender) {
              sender.replaceTrack(videoTrack);
            }
          }
          
          // Listen for when user stops sharing via browser UI
          screenStream.getVideoTracks()[0].onended = () => {
            toggleScreenShare();
          };
          
          isScreenSharing = true;
          toggleScreenShareBtn.classList.add('active');
          toggleScreenShareBtn.innerHTML = `
            <svg width="20" height="20" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
              <rect x="2" y="3" width="20" height="14" rx="2" ry="2"></rect>
              <line x1="8" y1="21" x2="16" y2="21"></line>
              <line x1="12" y1="17" x2="12" y2="21"></line>
            </svg>
            Stop Sharing
          `;
          
          // Notify others
          socket.emit('start-screen-share', { roomId: currentRoom });
          showToast('Screen sharing started', 'success');
          
        } catch (error) {
          console.error('Error starting screen share:', error);
          showToast('Error starting screen share: ' + error.message, 'error');
        }
      }
    }
    
    function toggleMute() {
      if (!localStream) return;
      
      const audioTracks = localStream.getAudioTracks();
      if (audioTracks.length === 0) return;
      
      const audioTrack = audioTracks[0];
      audioTrack.enabled = !audioTrack.enabled;
      
      isMuted = !audioTrack.enabled;
      toggleMuteBtn.classList.toggle('muted', isMuted);
      toggleMuteBtn.innerHTML = isMuted ? `
        <svg width="20" height="20" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
          <line x1="1" y1="1" x2="23" y2="23"></line>
          <path d="M9 9v3a3 3 0 0 0 5.12 2.12M15 9.34V4a3 3 0 0 0-5.94-.6"></path>
          <path d="M17 16.95A7 7 0 0 1 5 12v-2m14 0v2a7 7 0 0 1-.11 1.23"></path>
          <line x1="12" y1="19" x2="12" y2="23"></line>
          <line x1="8" y1="23" x2="16" y2="23"></line>
        </svg>
        Unmute
      ` : `
        <svg width="20" height="20" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
          <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path>
          <path d="M19 10v2a7 7 0 0 1-14 0v-2"></path>
          <line x1="12" y1="19" x2="12" y2="23"></line>
          <line x1="8" y1="23" x2="16" y2="23"></line>
        </svg>
        Mute
      `;
      
      // Update local mic status indicator
      document.getElementById('localMicStatus').style.color = isMuted ? 'var(--danger-color)' : 'white';
      
      showToast(isMuted ? 'Microphone muted' : 'Microphone unmuted', 'info');
    }
    
    function toggleVideo() {
      if (!localStream) return;
      
      const videoTracks = localStream.getVideoTracks();
      if (videoTracks.length === 0) return;
      
      const videoTrack = videoTracks[0];
      videoTrack.enabled = !videoTrack.enabled;
      
      isVideoOff = !videoTrack.enabled;
      toggleVideoBtn.classList.toggle('video-off', isVideoOff);
      localVideoCard.classList.toggle('video-off', isVideoOff);
      
      toggleVideoBtn.innerHTML = isVideoOff ? `
        <svg width="20" height="20" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
          <line x1="1" y1="1" x2="23" y2="23"></line>
          <path d="M13.79 8.21L15.17 6.79C19.47 11.1 19.47 12.9 15.17 17.21L13.79 15.79C16.53 13.04 16.53 10.96 13.79 8.21Z"></path>
          <path d="M6.53 9.47L8.53 11.47L10.53 13.47L7.53 16.47C6.39 15.33 5.82 14.02 5.82 12.5C5.82 10.98 6.39 9.67 7.53 8.53L6.53 9.47Z"></path>
        </svg>
        Show Video
      ` : `
        <svg width="20" height="20" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
          <polygon points="23 7 16 12 23 17 23 7"></polygon>
          <rect x="1" y="5" width="15" height="14" rx="2" ry="2"></rect>
        </svg>
        Hide Video
      `;
      
      // Update local camera status indicator
      document.getElementById('localCameraStatus').style.color = isVideoOff ? 'var(--danger-color)' : 'white';
      
      showToast(isVideoOff ? 'Camera turned off' : 'Camera turned on', 'info');
    }

    // Meeting duration timer
    let meetingInterval;
    let meetingSeconds = 0;

    function startMeetingTimer() {
      const meetingDuration = document.getElementById('meetingDuration');
      meetingSeconds = 0;
      
      meetingInterval = setInterval(() => {
        meetingSeconds++;
        const hours = Math.floor(meetingSeconds / 3600).toString().padStart(2, '0');
        const minutes = Math.floor((meetingSeconds % 3600) / 60).toString().padStart(2, '0');
        const seconds = (meetingSeconds % 60).toString().padStart(2, '0');
        meetingDuration.textContent = `${hours}:${minutes}:${seconds}`;
      }, 1000);
    }
    
    // Update participants list
    function updateParticipantsList() {
      const participantsList = document.getElementById('participantsList');
      const panelHeader = document.querySelector('.panel-header h3');
      
      // Clear current list
      participantsList.innerHTML = '';
      
      // Add local user (you)
      const localParticipant = document.createElement('div');
      localParticipant.className = 'participant-item';
      localParticipant.innerHTML = `
        <div class="participant-avatar" style="width:36px;height:36px;font-size:1rem;">
          ${userName ? userName.charAt(0).toUpperCase() : 'Y'}
        </div>
        <div class="participant-info">
          <div class="participant-name">${userName || 'You'} (You)</div>
          <div class="participant-role">Host</div>
        </div>
        <div class="participant-controls">
          <button class="action-icon" title="${isMuted ? 'Unmute' : 'Mute'}" id="localMuteIndicator" style="color: ${isMuted ? 'var(--danger-color)' : 'white'}">
            <svg width="16" height="16" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
              <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path>
              <path d="M19 10v2a7 7 0 0 1-14 0v-2"></path>
              <line x1="12" y1="19" x2="12" y2="23"></line>
              <line x1="8" y1="23" x2="16" y2="23"></line>
            </svg>
          </button>
        </div>
      `;
      
      participantsList.appendChild(localParticipant);
      
      // Add remote participants
      participants.forEach(participant => {
        const participantItem = document.createElement('div');
        participantItem.className = 'participant-item';
        participantItem.innerHTML = `
          <div class="participant-avatar" style="width:36px;height:36px;font-size:1rem;">
            ${participant.name.charAt(0).toUpperCase()}
          </div>
          <div class="participant-info">
            <div class="participant-name">${participant.name}</div>
            <div class="participant-role">Participant</div>
          </div>
          <div class="participant-controls">
            <button class="action-icon" title="Mute">
              <svg width="16" height="16" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
                <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path>
                <path d="M19 10v2a7 7 0 0 1-14 0v-2"></path>
                <line x1="12" y1="19" x2="12" y2="23"></line>
                <line x1="8" y1="23" x2="16" y2="23"></line>
              </svg>
            </button>
          </div>
        `;
        
        participantsList.appendChild(participantItem);
      });
      
      // Update count in panel header
      panelHeader.textContent = `Participants (${participants.length + 1})`;
    }
    
    // Update user avatars
    function updateAvatars() {
      if (userName) {
        localAvatar.textContent = userName.charAt(0).toUpperCase();
      }
      
      if (remoteUserDisplayName) {
        remoteAvatar.textContent = remoteUserDisplayName.charAt(0).toUpperCase();
      }
    }
    
    // Show toast notification
    function showToast(message, type = 'info') {
      const toastContainer = document.getElementById('toastContainer');
      
      const toast = document.createElement('div');
      toast.className = `toast toast-${type}`;
      
      // Get appropriate icon based on type
      let iconSvg = '';
      switch (type) {
        case 'success':
          iconSvg = `<svg width="18" height="18" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
            <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path>
            <polyline points="22 4 12 14.01 9 11.01"></polyline>
          </svg>`;
          break;
        case 'error':
          iconSvg = `<svg width="18" height="18" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
            <circle cx="12" cy="12" r="10"></circle>
            <line x1="12" y1="8" x2="12" y2="12"></line>
            <line x1="12" y1="16" x2="12.01" y2="16"></line>
          </svg>`;
          break;
        case 'warning':
          iconSvg = `<svg width="18" height="18" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
            <path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path>
            <line x1="12" y1="9" x2="12" y2="13"></line>
            <line x1="12" y1="17" x2="12.01" y2="17"></line>
          </svg>`;
          break;
        default: // info
          iconSvg = `<svg width="18" height="18" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
            <circle cx="12" cy="12" r="10"></circle>
            <line x1="12" y1="16" x2="12" y2="12"></line>
            <line x1="12" y1="8" x2="12.01" y2="8"></line>
          </svg>`;
      }
      
      toast.innerHTML = `
        <div class="toast-icon">${iconSvg}</div>
        <div class="toast-content">
          <div class="toast-title">${type.charAt(0).toUpperCase() + type.slice(1)}</div>
          <div class="toast-message">${message}</div>
        </div>
        <div class="toast-close">×</div>
      `;
      
      toastContainer.appendChild(toast);
      
      // Close button functionality
      toast.querySelector('.toast-close').addEventListener('click', () => {
        toast.remove();
      });
      
      // Auto remove after 5 seconds
      setTimeout(() => {
        if (toast.parentNode) {
          toast.remove();
        }
      }, 5000);
    }
    
    // Expose to window for modules
    window.showToast = showToast;
    
    // Apply video filter
    function applyVideoFilter(videoElement) {
      const filters = [
        'none',
        'grayscale(100%)',
        'sepia(100%)',
        'saturate(200%)',
        'hue-rotate(90deg)',
        'invert(100%)',
        'brightness(150%)',
        'contrast(200%)'
      ];
      
      // Get current filter or default to none
      const currentFilter = videoElement.style.filter || 'none';
      const currentIndex = filters.indexOf(currentFilter);
      const nextIndex = (currentIndex + 1) % filters.length;
      
      // Apply next filter
      videoElement.style.filter = filters[nextIndex];
      
      showToast(`Filter applied: ${filters[nextIndex]}`, 'info');
    }
    
    // Focus on a video card
    function focusVideo(videoCard) {
      if (videoCard.classList.contains('focused')) {
        videoCard.classList.remove('focused');
        document.querySelectorAll('.video-card').forEach(card => {
          card.style.display = 'flex';
        });
      } else {
        document.querySelectorAll('.video-card').forEach(card => {
          if (card !== videoCard) {
            card.style.display = 'none';
          }
        });
        videoCard.classList.add('focused');
      }
    }
    
    // Take a snapshot of video
    function takeSnapshot(videoElement) {
      if (!videoElement.srcObject) {
        showToast('No video stream available', 'error');
        return;
      }
      
      const canvas = document.createElement('canvas');
      canvas.width = videoElement.videoWidth;
      canvas.height = videoElement.videoHeight;
      
      const ctx = canvas.getContext('2d');
      ctx.drawImage(videoElement, 0, 0, canvas.width, canvas.height);
      
      // Create download link
      const link = document.createElement('a');
      link.download = `snapshot-${new Date().toISOString()}.png`;
      link.href = canvas.toDataURL('image/png');
      link.click();
      
      showToast('Snapshot saved', 'success');
    }
    
    // Copy to clipboard helper
    function copyToClipboard(text) {
      const textarea = document.createElement('textarea');
      textarea.value = text;
      textarea.style.position = 'fixed';
      document.body.appendChild(textarea);
      textarea.select();
      document.execCommand('copy');
      document.body.removeChild(textarea);
    }

    // Live Transcription
    if ('SpeechRecognition' in window || 'webkitSpeechRecognition' in window) {
      const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
      const recognition = new SpeechRecognition();
      recognition.continuous = true;
      recognition.interimResults = true;
      recognition.lang = 'en-US';
      let lastTranscript = '';
      recognition.onresult = event => {
        const transcript = Array.from(event.results)
          .map(result => result[0].transcript)
          .join(' ');
        transcriptDiv.innerHTML = transcript;
        lastTranscript = transcript;
      };
      recognition.onerror = event => {
        transcriptDiv.innerHTML = `<span style='color:#e74c3c'>Speech recognition error: ${event.error}</span>`;
      };
      recognition.onend = () => {
        // Auto-restart for continuous experience
        recognition.start();
      };
      recognition.start();
    } else {
      transcriptDiv.innerHTML = "<span style='color:#e74c3c'>Speech recognition is not supported in this browser.</span>";
    }
    
    // Initialize our enhanced features
    window.addEventListener('load', () => {
      // Add some particles to the background for enhanced visual effect
      addBackgroundParticles();
      
      // Initialize participant list
      updateParticipantsList();
      
      // Initialize encryption
      initializeEncryption();
      
      // Initialize recording
      initializeRecording();
    });
    
    // Initialize end-to-end encryption
    async function initializeEncryption() {
      const encryptionIndicator = document.getElementById('encryptionIndicator');
      const encryptionStatus = document.getElementById('encryptionStatus');
      
      encryptionIndicator.className = 'encryption-indicator initializing';
      encryptionStatus.textContent = 'Initializing...';
      
      if (!E2EEncryptionManager.isSupported()) {
        encryptionIndicator.className = 'encryption-indicator inactive';
        encryptionStatus.textContent = 'Not Supported';
        showToast('End-to-end encryption is not supported in this browser', 'warning');
        return;
      }
      
      try {
        const result = await encryptionManager.initialize();
        if (result.success) {
          encryptionInitialized = true;
          encryptionIndicator.className = 'encryption-indicator active';
          encryptionStatus.textContent = 'Secure';
          showToast('End-to-end encryption initialized', 'success');
          
          // Listen for encryption-related socket events
          setupEncryptionSocketEvents();
          
          // Share our public key with the room
          socket.emit('public-key', {
            publicKey: result.publicKey,
            roomId: currentRoom
          });
        } else {
          encryptionIndicator.className = 'encryption-indicator inactive';
          encryptionStatus.textContent = 'Disabled';
          showToast('Failed to initialize encryption: ' + result.error, 'error');
        }
      } catch (error) {
        encryptionIndicator.className = 'encryption-indicator inactive';
        encryptionStatus.textContent = 'Error';
        showToast('Encryption initialization error: ' + error.message, 'error');
      }
    }
    
    // Set up socket events for encryption
    function setupEncryptionSocketEvents() {
      const encryptionIndicator = document.getElementById('encryptionIndicator');
      const encryptionStatus = document.getElementById('encryptionStatus');
      
      // Listen for public key sharing
      socket.on('public-key', async (data) => {
        try {
          const success = await encryptionManager.receivePublicKey(data.publicKey);
          if (success) {
            // Send our encrypted session key
            const result = await encryptionManager.establishSecureChannel();
            if (result.success) {
              socket.emit('encrypted-session-key', {
                encryptedSessionKey: result.encryptedSessionKey,
                target: data.sender
              });
            }
          }
        } catch (error) {
          console.error('Error handling public key:', error);
          encryptionIndicator.className = 'encryption-indicator inactive';
          encryptionStatus.textContent = 'Failed';
        }
      });
      
      // Listen for encrypted session key
      socket.on('encrypted-session-key', async (data) => {
        try {
          const result = await encryptionManager.receiveEncryptedSessionKey(data.encryptedSessionKey);
          if (result.success) {
            console.log('Secure channel established');
            encryptionIndicator.className = 'encryption-indicator active';
            encryptionStatus.textContent = 'Secure';
            showToast('Secure connection established', 'success');
          }
        } catch (error) {
          console.error('Error processing encrypted session key:', error);
          encryptionIndicator.className = 'encryption-indicator inactive';
          encryptionStatus.textContent = 'Failed';
        }
      });
    }
    
    // Initialize recording functionality
    function initializeRecording() {
      const recordingConfig = {
        localVideo: document.getElementById('localVideo'),
        remoteVideo: document.getElementById('remoteVideo'),
        recordingIndicator: document.getElementById('recordingIndicator'),
        recordingTimer: document.getElementById('recordingTime'),
        onRecordingStart: () => {
          isRecording = true;
          showToast('Recording started', 'info');
          
          // Notify others
          socket.emit('recording-started', { roomId: currentRoom });
          
          // Update UI
          fabRecord.innerHTML = `
            <svg width="20" height="20" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
              <rect x="6" y="4" width="4" height="16"></rect>
              <rect x="14" y="4" width="4" height="16"></rect>
            </svg>
            Stop Recording
          `;
          fabRecord.classList.add('active');
        },
        onRecordingStop: (recordingData) => {
          isRecording = false;
          showToast('Recording stopped', 'info');
          
          // Notify others
          socket.emit('recording-stopped', { roomId: currentRoom });
          
          // Update UI
          fabRecord.innerHTML = `
            <svg width="20" height="20" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
              <circle cx="12" cy="12" r="10"></circle>
              <circle cx="12" cy="12" r="3" fill="currentColor"></circle>
            </svg>
            Record
          `;
          fabRecord.classList.remove('active');
          
          // Ask user if they want to download the recording
          if (confirm('Do you want to download the recording?')) {
            recordingManager.downloadRecording(recordingData.blob);
          }
        },
        onRecordingError: (error) => {
          showToast('Recording error: ' + error.message, 'error');
          isRecording = false;
          
          // Update UI
          fabRecord.innerHTML = `
            <svg width="20" height="20" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
              <circle cx="12" cy="12" r="10"></circle>
              <circle cx="12" cy="12" r="3" fill="currentColor"></circle>
            </svg>
            Record
          `;
          fabRecord.classList.remove('active');
        }
      };
      
      recordingInitialized = recordingManager.initialize(recordingConfig);
      
      if (!recordingInitialized) {
        showToast('Recording is not supported in this browser', 'warning');
      }
    }
    
    // Start recording function
    async function startRecording() {
      if (!recordingInitialized) {
        showToast('Recording is not supported or not initialized', 'error');
        return;
      }
      
      if (isRecording) {
        showToast('Recording already in progress', 'warning');
        return;
      }
      
      if (!localStream || !remoteVideo.srcObject) {
        showToast('Cannot record: Local or remote stream not available', 'error');
        return;
      }
      
      const success = await recordingManager.startRecording(
        localStream,
        remoteVideo.srcObject
      );
      
      if (!success) {
        showToast('Failed to start recording', 'error');
      }
    }
    
    // Stop recording function
    function stopRecording() {
      if (!isRecording) {
        showToast('No recording in progress', 'warning');
        return;
      }
      
      const success = recordingManager.stopRecording();
      if (!success) {
        showToast('Failed to stop recording', 'error');
      }
    }
  </script>
</body>
</html>
